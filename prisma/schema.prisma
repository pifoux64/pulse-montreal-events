// Pulse - Schéma Prisma complet pour l'agenda culturel de Montréal
// Générateur et configuration

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums
enum UserRole {
  USER
  ORGANIZER
  VENUE
  ADMIN
}

enum VenueClaimStatus {
  UNCLAIMED
  PENDING
  VERIFIED
  REJECTED
}

enum EventSource {
  INTERNAL
  EVENTBRITE
  TICKETMASTER
  MEETUP
  BANDSINTOWN
  SEATGEEK
  MTL_OPEN_DATA
  QUARTIER_SPECTACLES
  TOURISME_MONTREAL
  LAVITRINE
  ALLEVENTS
  LEPOINTDEVENTE
}

enum EventStatus {
  SCHEDULED
  UPDATED
  CANCELLED
}

enum EventLanguage {
  FR
  EN
  BOTH
}

enum EventCategory {
  MUSIC
  THEATRE
  EXHIBITION
  FAMILY
  SPORT
  NIGHTLIFE
  EDUCATION
  COMMUNITY
  OTHER
}

enum PromotionKind {
  HOMEPAGE
  LIST_TOP
  MAP_TOP
}

enum PromotionStatus {
  DRAFT
  ACTIVE
  EXPIRED
}

enum SubscriptionPlan {
  // Plans organisateurs
  ORGANIZER_BASIC // Gratuit - limité
  ORGANIZER_PRO // Payant - illimité + stats + support
  // Plans salles
  VENUE_BASIC // Gratuit - limité
  VENUE_PRO // Payant - demandes illimitées + visibilité premium + stats
}

enum EventPostType {
  TEXT
  MEDIA
}

enum MediaKind {
  IMAGE
  VIDEO
}

enum NotificationType {
  EVENT_POST_PUBLISHED
  EVENT_REMINDER
  SYSTEM
}

enum AdPlacementArea {
  HOMEPAGE
  SIDEBAR
  LIST
  MAP
}

enum ImportJobStatus {
  PENDING
  RUNNING
  SUCCESS
  ERROR
}

enum SourceType {
  API
  RSS
  ICS
  OPEN_DATA
  MANUAL
}

enum LegalStatus {
  VERIFIED
  PENDING_VERIFICATION
  UNVERIFIED
}

// Modèles principaux

model User {
  id            String    @id @default(uuid()) @db.Uuid
  name          String?
  email         String    @unique
  image         String?
  emailVerified DateTime? @map("email_verified")
  role          UserRole  @default(USER) // Legacy: gardé pour compatibilité, utiliser UserRoleAssignment
  roles         UserRoleAssignment[] // Multi-rôles support
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  // Relations
  organizer                 Organizer?
  favorites                 Favorite[]
  preferences               UserPreferences?
  notifications             Notification[]
  eventPosts                EventPost[]
  notificationSubscriptions NotificationSubscription[]
  musicServiceConnections   MusicServiceConnection[]
  interestTags              UserInterestTag[]
  accounts                  Account[]
  sessions                  Session[]
  organizerFollows          OrganizerFollow[]          @relation("UserFollows")
  eventInteractions         UserEventInteraction[]
  tasteProfile              UserTasteProfile?
  EditorialPost             EditorialPost[]
  ownedVenues               Venue[]                    @relation("VenueOwner")
  following                 UserFollow[]               @relation("UserFollowing")
  followers                 UserFollow[]               @relation("UserFollowers")
  sentInvitations           EventInvitation[]          @relation("InvitationSender")
  receivedInvitations       EventInvitation[]          @relation("InvitationReceiver")
  sentMessages              Message[]                  @relation("MessageSender")
  receivedMessages          Message[]                  @relation("MessageReceiver")
  roleAssignments           UserRoleAssignment[]
  venueClaims               VenueClaim[]
  reviewedVenueClaims        VenueClaim[]               @relation("VenueClaimReviewer")

  @@map("users")
}

model Account {
  id                 String  @id @default(cuid())
  userId             String  @map("user_id") @db.Uuid
  type               String
  provider           String
  providerAccountId  String  @map("provider_account_id")
  refresh_token      String? @db.Text
  access_token       String? @db.Text
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String? @db.Text
  session_state      String?
  oauth_token_secret String?
  oauth_token        String?

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id") @db.Uuid
  expires      DateTime

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token], name: "identifier_token")
  @@map("verification_tokens")
}

model Organizer {
  id          String  @id @default(uuid()) @db.Uuid
  userId      String  @unique @map("user_id") @db.Uuid
  displayName String  @map("display_name")
  slug        String? @unique // Slug pour URL SEO-friendly (optionnel pour migration)
  website     String?
  socials     Json? // JSON pour réseaux sociaux
  verified    Boolean @default(false)

  // Relations
  user                User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  events              Event[]
  subscriptions       Subscription[]       @relation("OrganizerSubscriptions")
  platformConnections PlatformConnection[]
  publicationLogs     PublicationLog[]
  followers           OrganizerFollow[]
  venueRequests       VenueRequest[]

  @@index([slug], name: "idx_organizer_slug")
  @@map("organizers")
}

// SPRINT 6: Suivre un organisateur pour recevoir des notifications
model OrganizerFollow {
  id          String   @id @default(uuid()) @db.Uuid
  userId      String   @map("user_id") @db.Uuid
  organizerId String   @map("organizer_id") @db.Uuid
  createdAt   DateTime @default(now()) @map("created_at")

  // Relations
  user      User      @relation("UserFollows", fields: [userId], references: [id], onDelete: Cascade)
  organizer Organizer @relation(fields: [organizerId], references: [id], onDelete: Cascade)

  @@unique([userId, organizerId], name: "unique_user_organizer_follow")
  @@index([userId], name: "idx_organizer_follow_user")
  @@index([organizerId], name: "idx_organizer_follow_organizer")
  @@map("organizer_follows")
}

model Venue {
  id           String   @id @default(uuid()) @db.Uuid
  name         String
  slug         String?  @unique // Slug pour URL SEO-friendly (optionnel pour migration)
  description  String?  @db.Text
  capacity     Int? // Capacité maximale de la salle
  address      String
  city         String
  postalCode   String   @map("postal_code")
  lat          Float
  lon          Float
  neighborhood String?
  phone        String?
  website      String?
  contactEmail String?  @map("contact_email")
  imageUrl     String?  @map("image_url") // URL de l'image principale de la salle
  types        String[] @default([]) // ["bar", "club", "salle", "centre_culturel"]
  tags         String[] @default([]) // Tags pour recherche et filtrage
  ownerUserId  String?  @map("owner_user_id") @db.Uuid
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  // Relations
  events        Event[]
  owner         User?          @relation("VenueOwner", fields: [ownerUserId], references: [id], onDelete: SetNull)
  requests      VenueRequest[]
  subscriptions Subscription[] @relation("VenueSubscriptions")
  claims        VenueClaim[]

  // Index pour recherche géospatiale et SEO
  @@index([lat, lon], name: "idx_venue_coordinates")
  @@index([slug], name: "idx_venue_slug")
  @@index([ownerUserId], name: "idx_venue_owner")
  @@index([types], name: "idx_venue_types")
  @@map("venues")
}

enum VenueRequestStatus {
  PENDING
  ACCEPTED
  DECLINED
}

model VenueRequest {
  id                 String             @id @default(uuid()) @db.Uuid
  venueId            String             @map("venue_id") @db.Uuid
  organizerId        String             @map("organizer_id") @db.Uuid
  concept            String             @db.Text // Description du concept d'événement
  dateStart          DateTime           @map("date_start")
  dateEnd            DateTime?          @map("date_end")
  expectedAttendance Int?               @map("expected_attendance") // Nombre de personnes attendues
  budget             Int? // Budget en cents (CAD)
  status             VenueRequestStatus @default(PENDING)
  comments           String?            @db.Text // Commentaires de la salle ou de l'organisateur
  createdAt          DateTime           @default(now()) @map("created_at")
  updatedAt          DateTime           @updatedAt @map("updated_at")

  // Relations
  venue     Venue     @relation(fields: [venueId], references: [id], onDelete: Cascade)
  organizer Organizer @relation(fields: [organizerId], references: [id], onDelete: Cascade)

  @@index([venueId], name: "idx_venue_request_venue")
  @@index([organizerId], name: "idx_venue_request_organizer")
  @@index([status], name: "idx_venue_request_status")
  @@index([dateStart], name: "idx_venue_request_date_start")
  @@map("venue_requests")
}

model Event {
  id             String        @id @default(uuid()) @db.Uuid
  source         EventSource   @default(INTERNAL)
  sourceId       String?       @map("source_id")
  title          String
  description    String        @db.Text
  startAt        DateTime      @map("start_at")
  endAt          DateTime?     @map("end_at")
  timezone       String        @default("America/Montreal")
  status         EventStatus   @default(SCHEDULED)
  organizerId    String?       @map("organizer_id") @db.Uuid
  venueId        String?       @map("venue_id") @db.Uuid
  url            String?
  priceMin       Int?          @map("price_min") // en cents
  priceMax       Int?          @map("price_max") // en cents
  currency       String        @default("CAD")
  language       EventLanguage @default(FR)
  imageUrl       String?       @map("image_url")
  tags           String[]      @default([])
  category       EventCategory
  subcategory    String?
  accessibility  String[]      @default([]) // ["wheelchair", "hearing_aid", etc.]
  ageRestriction String?       @map("age_restriction")
  createdAt      DateTime      @default(now()) @map("created_at")
  updatedAt      DateTime      @updatedAt @map("updated_at")

  // Relations
  organizer        Organizer?             @relation(fields: [organizerId], references: [id], onDelete: SetNull)
  venue            Venue?                 @relation(fields: [venueId], references: [id], onDelete: SetNull)
  features         EventFeature[]
  favorites        Favorite[]
  promotions       Promotion[]
  notifications    Notification[]
  posts            EventPost[]
  eventTags        EventTag[]
  eventSources     EventSourceLink[] // SPRINT A: Plusieurs sources pour un même événement
  userInteractions UserEventInteraction[]
  invitations      EventInvitation[]

  @@unique([sourceId, source], name: "unique_source_event")
  // Index pour performance
  @@index([title], name: "idx_event_title")
  @@index([startAt], name: "idx_event_start_at")
  @@index([category], name: "idx_event_category")
  @@index([tags], name: "idx_event_tags")
  @@index([status], name: "idx_event_status")
  @@index([organizerId], name: "idx_event_organizer")
  @@index([venueId], name: "idx_event_venue")
  @@map("events")
}

model EventTag {
  id        String   @id @default(uuid()) @db.Uuid
  eventId   String   @map("event_id") @db.Uuid
  category  String
  value     String
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@index([eventId], name: "idx_eventtag_event")
  @@index([category, value], name: "idx_eventtag_category_value")
  @@map("event_tags")
}

model TagDefinition {
  id        String   @id @default(uuid()) @db.Uuid
  category  String
  value     String
  label     String
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([category, value], name: "unique_tagdefinition")
  @@map("tag_definitions")
}

model EventFeature {
  id           String @id @default(uuid()) @db.Uuid
  eventId      String @map("event_id") @db.Uuid
  featureKey   String @map("feature_key")
  featureValue Json   @map("feature_value")

  // Relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([eventId, featureKey], name: "unique_event_feature")
  @@map("event_features")
}

model Favorite {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @map("user_id") @db.Uuid
  eventId   String   @map("event_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([userId, eventId], name: "unique_user_event_favorite")
  @@map("favorites")
}

model EventPost {
  id        String        @id @default(uuid()) @db.Uuid
  eventId   String        @map("event_id") @db.Uuid
  authorId  String        @map("author_id") @db.Uuid
  type      EventPostType @default(TEXT)
  content   String
  createdAt DateTime      @default(now()) @map("created_at")
  updatedAt DateTime      @updatedAt @map("updated_at")

  event  Event            @relation(fields: [eventId], references: [id], onDelete: Cascade)
  author User             @relation(fields: [authorId], references: [id], onDelete: Cascade)
  medias EventPostMedia[]

  @@map("event_posts")
}

model EventPostMedia {
  id        String    @id @default(uuid()) @db.Uuid
  postId    String    @map("post_id") @db.Uuid
  kind      MediaKind
  url       String
  createdAt DateTime  @default(now()) @map("created_at")

  post EventPost @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@map("event_post_medias")
}

model Promotion {
  id         String          @id @default(uuid()) @db.Uuid
  eventId    String          @map("event_id") @db.Uuid
  kind       PromotionKind
  status     PromotionStatus @default(DRAFT)
  startsAt   DateTime        @map("starts_at")
  endsAt     DateTime        @map("ends_at")
  priceCents Int             @map("price_cents") // prix en cents
  createdAt  DateTime        @default(now()) @map("created_at")
  updatedAt  DateTime        @updatedAt @map("updated_at")

  // Relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@index([eventId], name: "idx_promotion_event")
  @@index([status, kind, startsAt, endsAt], name: "idx_promotion_active")
  @@map("promotions")
}

model Subscription {
  id                   String           @id @default(uuid()) @db.Uuid
  organizerId          String?          @map("organizer_id") @db.Uuid // Nullable pour supporter les salles
  venueId              String?          @map("venue_id") @db.Uuid // Nullable pour supporter les organisateurs
  plan                 SubscriptionPlan
  billingMonthly       Int              @map("billing_monthly") // prix mensuel en cents
  active               Boolean          @default(true)
  stripeSubscriptionId String?          @map("stripe_subscription_id") // ID de l'abonnement Stripe
  stripeCustomerId     String?          @map("stripe_customer_id") // ID du client Stripe
  currentPeriodStart   DateTime?        @map("current_period_start")
  currentPeriodEnd     DateTime?        @map("current_period_end")
  cancelAtPeriodEnd    Boolean          @default(false) @map("cancel_at_period_end")
  createdAt            DateTime         @default(now()) @map("created_at")
  updatedAt            DateTime         @updatedAt @map("updated_at")

  // Relations
  organizer Organizer? @relation("OrganizerSubscriptions", fields: [organizerId], references: [id], onDelete: Cascade)
  venue     Venue?     @relation("VenueSubscriptions", fields: [venueId], references: [id], onDelete: Cascade)

  @@index([organizerId], name: "idx_subscription_organizer")
  @@index([venueId], name: "idx_subscription_venue")
  @@index([active], name: "idx_subscription_active")
  @@map("subscriptions")
}

model AdPlacement {
  id          String          @id @default(uuid()) @db.Uuid
  sponsorName String          @map("sponsor_name")
  area        AdPlacementArea
  startsAt    DateTime        @map("starts_at")
  endsAt      DateTime        @map("ends_at")
  priceCents  Int             @map("price_cents")
  targetJson  Json            @map("target_json") // ciblage par quartier, catégorie, etc.
  createdAt   DateTime        @default(now()) @map("created_at")

  @@map("ad_placements")
}

// SPRINT 3: Pulse Picks / Top 5 éditoriaux

enum EditorialPostStatus {
  DRAFT // En cours de rédaction
  SCHEDULED // Planifié pour une date donnée
  PUBLISHED // Visible publiquement
  ARCHIVED // Archivé
}

model EditorialPost {
  id            String              @id @default(uuid()) @db.Uuid
  slug          String              @unique // ex: "top-5-famille-week-2025-03-10"
  title         String
  theme         String // ex: "famille", "culture", "rock", "gratuit"
  description   String?             @db.Text // Texte éditorial écrit par l'humain
  status        EditorialPostStatus @default(DRAFT)
  periodStart   DateTime            @map("period_start") // Début de la période (ex: lundi de la semaine)
  periodEnd     DateTime            @map("period_end") // Fin de la période (ex: dimanche)
  eventsOrder   String[]            @default([]) @map("events_order") // Liste ordonnée d'IDs d'événements (Top 5)
  tags          String[]            @default([]) // Tags libres pour SEO/filtrage (\"famille\", \"gratuit\", etc.)
  coverImageUrl String?             @map("cover_image_url")
  createdAt     DateTime            @default(now()) @map("created_at")
  updatedAt     DateTime            @updatedAt @map("updated_at")
  publishedAt   DateTime?           @map("published_at")
  authorId      String?             @map("author_id") @db.Uuid

  // Relations
  author User? @relation(fields: [authorId], references: [id], onDelete: SetNull)

  @@index([theme, periodStart, periodEnd], name: "idx_editorial_theme_period")
  @@index([status, periodStart], name: "idx_editorial_status_period")
  @@map("editorial_posts")
}

// SPRINT A: Architecture d'ingestion générique
model Source {
  id               String      @id @default(uuid()) @db.Uuid
  name             String // Nom lisible de la source (ex: "Ville de Montréal - Données ouvertes")
  type             SourceType // API | RSS | ICS | OPEN_DATA | MANUAL
  eventSource      EventSource @map("event_source") // Correspondance avec EventSource enum (champ scalaire)
  legalStatus      LegalStatus @default(PENDING_VERIFICATION) @map("legal_status")
  isEnabled        Boolean     @default(true) @map("is_enabled")
  syncInterval     Int         @default(43200) @map("sync_interval") // en secondes (12h par défaut)
  lastSyncAt       DateTime?   @map("last_sync_at")
  config           Json // Configuration spécifique (URL, API keys, mapping, etc.)
  description      String?     @db.Text // Documentation de la source
  documentationUrl String?     @map("documentation_url") // Lien vers la documentation officielle
  createdAt        DateTime    @default(now()) @map("created_at")
  updatedAt        DateTime    @updatedAt @map("updated_at")

  // Relations
  importJobs       ImportJob[]
  health           SourceHealth?
  eventSourceLinks EventSourceLink[]

  @@index([type], name: "idx_source_type")
  @@index([isEnabled], name: "idx_source_enabled")
  @@index([legalStatus], name: "idx_source_legal_status")
  @@map("sources")
}

model ImportJob {
  id            String          @id @default(uuid()) @db.Uuid
  sourceId      String?         @map("source_id") @db.Uuid // Nouveau: référence à Source
  source        EventSource // Conservé pour compatibilité
  status        ImportJobStatus @default(PENDING)
  startedAt     DateTime        @default(now()) @map("started_at")
  finishedAt    DateTime?       @map("finished_at")
  runAt         DateTime        @map("run_at") // Conservé pour compatibilité (égal à startedAt)
  insertedCount Int             @default(0) @map("inserted_count") // Renommé de nbCreated
  updatedCount  Int             @default(0) @map("updated_count") // Renommé de nbUpdated
  skippedCount  Int             @default(0) @map("skipped_count") // Renommé de nbSkipped
  errorCount    Int             @default(0) @map("error_count") // Renommé de nbErrors
  // Champs legacy pour compatibilité (seront supprimés après migration)
  nbCreated     Int?            @default(0) @map("nb_created")
  nbUpdated     Int?            @default(0) @map("nb_updated")
  nbSkipped     Int?            @default(0) @map("nb_skipped")
  nbErrors      Int?            @default(0) @map("nb_errors")
  errorSample   String?         @map("error_sample") @db.Text // Exemple d'erreur
  logsUrl       String?         @map("logs_url") // URL vers les logs détaillés (optionnel)
  stats         Json? // statistiques d'import détaillées
  errorText     String?         @map("error_text") @db.Text // Conservé pour compatibilité

  // Relations
  sourceRef Source? @relation(fields: [sourceId], references: [id], onDelete: SetNull)

  @@index([sourceId, startedAt], name: "idx_import_job_source_started")
  @@index([source, startedAt], name: "idx_import_job_source_legacy")
  @@index([status], name: "idx_import_job_status")
  @@map("import_jobs")
}

model SourceHealth {
  id                  String    @id @default(uuid()) @db.Uuid
  sourceId            String    @unique @map("source_id") @db.Uuid
  lastSuccessAt       DateTime? @map("last_success_at")
  lastErrorAt         DateTime? @map("last_error_at")
  consecutiveFailures Int       @default(0) @map("consecutive_failures")
  nextRunAt           DateTime? @map("next_run_at")
  lastErrorMessage    String?   @map("last_error_message") @db.Text
  updatedAt           DateTime  @updatedAt @map("updated_at")

  // Relations
  source Source @relation(fields: [sourceId], references: [id], onDelete: Cascade)

  @@map("source_health")
}

// Table de jointure pour gérer plusieurs sources pour un même événement (déduplication)
model EventSourceLink {
  id         String      @id @default(uuid()) @db.Uuid
  eventId    String      @map("event_id") @db.Uuid
  sourceId   String?     @map("source_id") @db.Uuid // Référence à Source (nouveau système)
  source     EventSource // Source legacy (EventSource enum) - champ scalaire
  sourceUrl  String?     @map("source_url") // URL de l'événement sur la source
  externalId String?     @map("external_id") // ID externe de l'événement sur la source
  isPrimary  Boolean     @default(false) @map("is_primary") // Source principale (pour ticketUrl, etc.)
  createdAt  DateTime    @default(now()) @map("created_at")
  updatedAt  DateTime    @updatedAt @map("updated_at")

  // Relations
  event     Event   @relation(fields: [eventId], references: [id], onDelete: Cascade)
  sourceRef Source? @relation(fields: [sourceId], references: [id], onDelete: SetNull)

  @@unique([eventId, sourceId, source], name: "unique_event_source")
  @@index([eventId], name: "idx_event_source_event")
  @@index([sourceId], name: "idx_event_source_source")
  @@index([source], name: "idx_event_source_source_legacy")
  @@map("event_sources")
}

// Modèles pour les utilisateurs

model UserPreferences {
  id                     String   @id @default(uuid()) @db.Uuid
  userId                 String   @unique @map("user_id") @db.Uuid
  favoriteCategories     String[] @default([]) @map("favorite_categories")
  favoriteSubcategories  String[] @default([]) @map("favorite_subcategories")
  favoriteNeighborhoods  String[] @default([]) @map("favorite_neighborhoods")
  notificationsEmail     Boolean  @default(true) @map("notifications_email")
  notificationsPush      Boolean  @default(true) @map("notifications_push")
  notificationsFavorites Boolean  @default(true) @map("notifications_favorites")
  personalizationEnabled Boolean  @default(true) @map("personalization_enabled") // Activer/désactiver recommandations personnalisées
  language               String   @default("fr") @db.VarChar(2)
  timezone               String   @default("America/Montreal")
  defaultRadius          Int      @default(10) @map("default_radius") // en km
  // Nouveaux champs pour onboarding direct
  musicPreferences       String[] @default([]) @map("music_preferences") // Genres musicaux sélectionnés
  categoryPreferences    String[] @default([]) @map("category_preferences") // Catégories d'événements sélectionnées
  vibePreferences        String[] @default([]) @map("vibe_preferences") // Ambiances/vibes sélectionnées
  preferredDays          String[] @default([]) @map("preferred_days") // weekday, weekend
  preferredTimes         String[] @default([]) @map("preferred_times") // day, evening, night
  onboardingCompleted    Boolean  @default(false) @map("onboarding_completed") // Si l'onboarding a été complété
  createdAt              DateTime @default(now()) @map("created_at")
  updatedAt              DateTime @updatedAt @map("updated_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_preferences")
}

model Notification {
  id        String           @id @default(uuid()) @db.Uuid
  userId    String           @map("user_id") @db.Uuid
  eventId   String?          @map("event_id") @db.Uuid
  type      NotificationType
  title     String
  body      String           @db.Text
  data      Json?
  readAt    DateTime?        @map("read_at")
  createdAt DateTime         @default(now()) @map("created_at")

  // Relations
  user  User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  event Event? @relation(fields: [eventId], references: [id], onDelete: SetNull)

  @@index([userId, readAt], name: "idx_notification_user_read")
  @@map("notifications")
}

model NotificationSubscription {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @map("user_id") @db.Uuid
  endpoint  String
  authKey   String?  @map("auth_key")
  p256dhKey String?  @map("p256dh_key")
  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, endpoint])
  @@map("notification_subscriptions")
}

// Modèles pour les métadonnées

model Category {
  id            String  @id @default(uuid()) @db.Uuid
  name          String
  nameEn        String  @map("name_en")
  slug          String  @unique
  icon          String
  color         String
  description   String?
  descriptionEn String? @map("description_en")
  sortOrder     Int     @default(0) @map("sort_order")

  // Relations
  subcategories Subcategory[]

  @@map("categories")
}

model Subcategory {
  id            String  @id @default(uuid()) @db.Uuid
  categoryId    String  @map("category_id") @db.Uuid
  name          String
  nameEn        String  @map("name_en")
  slug          String
  description   String?
  descriptionEn String? @map("description_en")
  sortOrder     Int     @default(0) @map("sort_order")

  // Relations
  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@unique([categoryId, slug], name: "unique_category_subcategory_slug")
  @@map("subcategories")
}

model Neighborhood {
  id        String @id @default(uuid()) @db.Uuid
  name      String
  nameEn    String @map("name_en")
  slug      String @unique
  city      String @default("Montréal")
  province  String @default("QC")
  country   String @default("CA")
  bounds    Json? // GeoJSON polygon pour les limites
  centerLat Float? @map("center_lat")
  centerLon Float? @map("center_lon")

  @@map("neighborhoods")
}

// Modèles pour la recherche et analytics

model SearchQuery {
  id        String   @id @default(uuid()) @db.Uuid
  query     String
  filters   Json? // filtres appliqués
  results   Int      @default(0) // nombre de résultats
  userId    String?  @map("user_id") @db.Uuid
  sessionId String?  @map("session_id")
  createdAt DateTime @default(now()) @map("created_at")

  @@index([query], name: "idx_search_query")
  @@index([createdAt], name: "idx_search_created_at")
  @@map("search_queries")
}

model EventView {
  id        String   @id @default(uuid()) @db.Uuid
  eventId   String   @map("event_id") @db.Uuid
  userId    String?  @map("user_id") @db.Uuid
  sessionId String?  @map("session_id")
  userAgent String?  @map("user_agent")
  ipAddress String?  @map("ip_address")
  referrer  String?
  createdAt DateTime @default(now()) @map("created_at")

  @@index([eventId], name: "idx_event_view_event")
  @@index([createdAt], name: "idx_event_view_created_at")
  @@map("event_views")
}

model UserInterestTag {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @map("user_id") @db.Uuid
  category  String
  value     String
  score     Float    @default(0)
  source    String   @default("manual") // manual | spotify | apple_music | auto
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, category, value], name: "unique_user_tag_interest")
  @@index([userId, category], name: "idx_user_interest_user_category")
  @@map("user_interest_tags")
}

// SPRINT 6: Connexions Spotify / Apple Music pour recommandations personnalisées
model MusicServiceConnection {
  id             String    @id @default(uuid()) @db.Uuid
  userId         String    @map("user_id") @db.Uuid
  service        String // spotify | apple_music
  accessToken    String    @map("access_token") @db.Text
  refreshToken   String?   @map("refresh_token") @db.Text
  expiresAt      DateTime  @map("expires_at")
  externalUserId String    @map("external_user_id")
  scopes         String? // Scopes accordés lors de l'OAuth (ex: "user-top-read")
  lastSyncAt     DateTime? @map("last_sync_at")
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, service], name: "unique_user_music_service")
  @@index([userId], name: "idx_music_service_user")
  @@map("music_service_connections")
}

// SPRINT 4: Modèles pour publication multi-plateformes
model PlatformConnection {
  id             String    @id @default(uuid()) @db.Uuid
  organizerId    String    @map("organizer_id") @db.Uuid
  platform       String // 'facebook', 'eventbrite', 'bandsintown'
  platformUserId String?   @map("platform_user_id") // ID utilisateur/organisation sur la plateforme
  accessToken    String?   @map("access_token") @db.Text
  refreshToken   String?   @map("refresh_token") @db.Text
  expiresAt      DateTime? @map("expires_at")
  metadata       Json? // Données supplémentaires (pages Facebook, organisateurs Eventbrite, etc.)
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt @map("updated_at")

  organizer Organizer @relation(fields: [organizerId], references: [id], onDelete: Cascade)

  @@unique([organizerId, platform], name: "unique_organizer_platform")
  @@index([organizerId], name: "idx_platform_connection_organizer")
  @@map("platform_connections")
}

// SPRINT 2: Interactions utilisateur pour recommandations personnalisées
enum UserEventInteractionType {
  VIEW // Vue de la page événement
  CLICK // Clic sur un événement (dans une liste)
  FAVORITE // Ajout aux favoris
  SHARE // Partage d'un événement
  DISMISS // "Pas intéressé" / rejet explicite
}

model UserEventInteraction {
  id        String                   @id @default(uuid()) @db.Uuid
  userId    String                   @map("user_id") @db.Uuid
  eventId   String                   @map("event_id") @db.Uuid
  type      UserEventInteractionType
  createdAt DateTime                 @default(now()) @map("created_at")

  // Relations
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([userId, eventId, type], name: "unique_user_event_interaction")
  @@index([userId, type, createdAt], name: "idx_user_interaction_user_type_created")
  @@index([eventId], name: "idx_user_interaction_event")
  @@index([createdAt], name: "idx_user_interaction_created_at")
  @@map("user_event_interactions")
}

// SPRINT 2: Profil de goûts agrégé (recomputed nightly)
model UserTasteProfile {
  id                     String   @id @default(uuid()) @db.Uuid
  userId                 String   @unique @map("user_id") @db.Uuid
  topTags                Json     @default("{}") @map("top_tags") // { tag: weight }
  topGenres              Json     @default("{}") @map("top_genres") // { genre: weight }
  preferredNeighborhoods Json     @default("[]") @map("preferred_neighborhoods") // string[]
  preferredTimeSlots     Json     @default("{}") @map("preferred_time_slots") // { hour: count }
  lastComputedAt         DateTime @default(now()) @map("last_computed_at")
  createdAt              DateTime @default(now()) @map("created_at")
  updatedAt              DateTime @updatedAt @map("updated_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId], name: "idx_taste_profile_user")
  @@map("user_taste_profiles")
}

model PublicationLog {
  id               String   @id @default(uuid()) @db.Uuid
  eventId          String   @map("event_id") @db.Uuid
  organizerId      String   @map("organizer_id") @db.Uuid
  platform         String // 'facebook', 'eventbrite', 'resident_advisor', 'bandsintown'
  status           String // 'success', 'error', 'pending'
  platformEventId  String?  @map("platform_event_id") // ID de l'événement sur la plateforme
  platformEventUrl String?  @map("platform_event_url") // URL de l'événement sur la plateforme
  errorMessage     String?  @map("error_message") @db.Text
  metadata         Json? // Données supplémentaires (réponse API, etc.)
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt @map("updated_at")

  organizer Organizer @relation(fields: [organizerId], references: [id], onDelete: Cascade)

  @@index([eventId], name: "idx_publication_log_event")
  @@index([organizerId], name: "idx_publication_log_organizer")
  @@index([platform], name: "idx_publication_log_platform")
  @@index([status], name: "idx_publication_log_status")
  @@map("publication_logs")
}

// SPRINT 6: Suivre des amis (User → User)
model UserFollow {
  id          String   @id @default(uuid()) @db.Uuid
  followerId  String   @map("follower_id") @db.Uuid // Celui qui suit
  followingId String   @map("following_id") @db.Uuid // Celui qui est suivi
  createdAt   DateTime @default(now()) @map("created_at")

  // Relations
  follower  User @relation("UserFollowing", fields: [followerId], references: [id], onDelete: Cascade)
  following User @relation("UserFollowers", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId], name: "unique_user_follow")
  @@index([followerId], name: "idx_user_follow_follower")
  @@index([followingId], name: "idx_user_follow_following")
  @@map("user_follows")
}

// SPRINT 6: Invitations Pulse → Pulse
model EventInvitation {
  id          String    @id @default(uuid()) @db.Uuid
  eventId     String    @map("event_id") @db.Uuid
  senderId    String    @map("sender_id") @db.Uuid
  receiverId  String    @map("receiver_id") @db.Uuid
  message     String?   @db.Text // Message personnalisé
  status      String    @default("PENDING") // PENDING | ACCEPTED | DECLINED
  createdAt   DateTime  @default(now()) @map("created_at")
  respondedAt DateTime? @map("responded_at")

  // Relations
  sender   User  @relation("InvitationSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver User  @relation("InvitationReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  event    Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([eventId, senderId, receiverId], name: "unique_event_invitation")
  @@index([senderId], name: "idx_invitation_sender")
  @@index([receiverId], name: "idx_invitation_receiver")
  @@index([eventId], name: "idx_invitation_event")
  @@index([status], name: "idx_invitation_status")
  @@index([receiverId, status], name: "idx_invitation_receiver_status")
  @@map("event_invitations")
}

// Messagerie entre utilisateurs
model Message {
  id         String    @id @default(uuid()) @db.Uuid
  senderId   String    @map("sender_id") @db.Uuid
  receiverId String    @map("receiver_id") @db.Uuid
  content    String    @db.Text
  read       Boolean   @default(false)
  createdAt  DateTime  @default(now()) @map("created_at")
  readAt     DateTime? @map("read_at")

  // Relations
  sender   User @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver User @relation("MessageReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  @@index([senderId], name: "idx_message_sender")
  @@index([receiverId], name: "idx_message_receiver")
  @@index([read], name: "idx_message_read")
  @@index([createdAt], name: "idx_message_created_at")
  @@map("messages")
}

// Système multi-rôles: permet à un utilisateur d'avoir plusieurs rôles simultanément
model UserRoleAssignment {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @map("user_id") @db.Uuid
  role      UserRole
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, role], name: "unique_user_role")
  @@index([userId], name: "idx_user_role_user")
  @@index([role], name: "idx_user_role_role")
  @@map("user_role_assignments")
}

// Système de claim de venues: permet aux utilisateurs de revendiquer une venue
model VenueClaim {
  id              String           @id @default(uuid()) @db.Uuid
  venueId         String           @map("venue_id") @db.Uuid
  userId          String           @map("user_id") @db.Uuid
  status          VenueClaimStatus @default(PENDING)
  roleAtVenue     String?          @map("role_at_venue") // "owner", "manager", "booker"
  professionalEmail String?        @map("professional_email")
  website         String?
  socialLink      String?          @map("social_link")
  submittedInfo   Json?            @map("submitted_info") // Informations supplémentaires
  reviewedBy      String?          @map("reviewed_by") @db.Uuid // Admin qui a approuvé/rejeté
  reviewedAt      DateTime?       @map("reviewed_at")
  rejectionReason String?         @map("rejection_reason") @db.Text
  createdAt       DateTime         @default(now()) @map("created_at")
  updatedAt       DateTime         @updatedAt @map("updated_at")

  // Relations
  venue     Venue @relation(fields: [venueId], references: [id], onDelete: Cascade)
  user      User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  reviewer  User? @relation("VenueClaimReviewer", fields: [reviewedBy], references: [id], onDelete: SetNull)

  @@unique([venueId, userId], name: "unique_venue_claim")
  @@index([venueId], name: "idx_venue_claim_venue")
  @@index([userId], name: "idx_venue_claim_user")
  @@index([status], name: "idx_venue_claim_status")
  @@map("venue_claims")
}
